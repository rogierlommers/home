<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>home service</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/milligram/1.4.1/milligram.min.css" />
  <link rel="stylesheet" href="https://milligram.io/styles/main.css" />
  <style>
    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      color: #888;
      margin-top: 2em;
      transition: border-color 0.2s;
    }

    .drop-zone.dragover {
      border-color: #333;
      background: #f9f9f9;
      color: #333;
    }

    .drop-zone input {
      display: none;
    }

    #progressContainer {
      width: 100%;
      background: #eee;
      border-radius: 4px;
      margin: 1em 0;
      height: 18px;
      display: none;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: #9b4dca;
      border-radius: 4px;
      transition: width 0.2s;
    }

    .logout-btn {
      margin-bottom: 2em;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #f4f4f4;
    }

    tr:hover {
      background-color: #f1f1f1;
    }
  </style>
</head>

<body>
  <main class="wrapper">

    <section class="container" id="examples">
      <h1 class="title">home service</h1>

      <h4><a href="/bookmarks">bookmarks</a> (<a href="/bookmarks/edit">#</a>) / <a href="/statistics">statistics</a> /
        <a href="notify">notify</a> / <a href="storage">storage</a>
      </h4>
      <!-- Add search box above bookmarks table -->
      <div style="margin-bottom: 1em;">
        <input type="text" id="bookmarkSearch" placeholder="Search..."
          style="width: 120px; font-size: 0.95em; padding: 4px 8px;" />
      </div>
      <div id="bookmarksTable" style="overflow-x:auto; margin-bottom:2em;">
        Loading bookmarks...
      </div>

      <form id="addBookmarkForm" style="margin-bottom:2em;">
        <div style="display: flex; flex-wrap: wrap; gap: 16px;">
          <div style="flex:1; min-width:180px;">
            <label for="bmTitle">Title</label>
            <input type="text" id="bmTitle" name="title" required />
          </div>
          <div style="flex:1; min-width:180px;">
            <label for="bmArg">URL</label>
            <input type="url" id="bmArg" name="arg" required />
          </div>
          <div style="flex:1; min-width:180px;">
            <label for="bmCategory">Category</label>
            <select id="bmCategory" name="category" required>
              <option value="">Loading...</option>
            </select>
          </div>
        </div>
        <button type="submit" class="button" style="margin-top:12px;">Add Bookmark</button>
        <span id="addBookmarkStatus" style="margin-left:1em;"></span>
      </form>

    </section>

    <script>

      function loadBookmarksTable() {
        fetch('/api/bookmarks')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => {
            console.log("Bookmarks API data:", data); // <-- Print the data to the console
            renderBookmarksTable(data);
          })
          .catch(() => {
            document.getElementById('bookmarksTable').textContent = 'Failed to load bookmarks.';
          });
      }

      // Add this near your other global variables
      let bookmarkSearchTerm = "";

      // Add event listener for the search box
      document.getElementById('bookmarkSearch').addEventListener('input', function (e) {
        bookmarkSearchTerm = e.target.value;
        // Re-render the table with the current data and search term
        fetch('/api/bookmarks')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => renderBookmarksTable(data));
      });

      // Add ESC key handler to clear search
      document.getElementById('bookmarkSearch').addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
          this.value = '';
          bookmarkSearchTerm = '';
          fetch('/api/bookmarks')
            .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
            .then(data => renderBookmarksTable(data));
        }
      });

      document.addEventListener('keydown', function (e) {
        if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'f') {
          e.preventDefault();
          e.stopPropagation();
          const searchBox = document.getElementById('bookmarkSearch');
          searchBox.focus();
          searchBox.select();
        }
      }, { capture: true });

      function renderBookmarksTable(data) {
        if (!data || !data.items) {
          console.warn("No bookmarks data or items:", data);
          document.getElementById('bookmarksTable').textContent = 'No bookmarks found.';
          return;
        }

        // Filter out bookmarks where hide_in_gui is true
        let items = data.items.filter(item => !item.hide_in_gui);

        // Filter items by search term (case-insensitive, matches title, URL, or autocomplete)
        if (bookmarkSearchTerm && bookmarkSearchTerm.trim() !== "") {
          const term = bookmarkSearchTerm.trim().toLowerCase();
          items = items.filter(item =>
            (item.title && item.title.toLowerCase().includes(term)) ||
            (item.arg && item.arg.toLowerCase().includes(term)) ||
            (item.autocomplete && item.autocomplete.toLowerCase().includes(term))
          );
        }

        // Generate unique category names from items using the mapping
        const categories = [
          ...new Set(
            items
              .map(item => categoryIdToName[item.category_id])
              .filter(Boolean)
          )
        ];

        // Group items by category name
        const grouped = {};
        categories.forEach(cat => grouped[cat] = []);
        items.forEach(item => {
          const catName = categoryIdToName[item.category_id];
          if (grouped[catName]) {
            grouped[catName].push(item);
          }
        });

        // Find max number of items in any category for row count
        const maxRows = Math.max(...categories.map(cat => grouped[cat].length));

        // Build table
        let html = `<table style="width:100%;border-collapse:collapse;table-layout:auto;">
          <thead>
            <tr>
              ${categories.map(cat => `<th>${cat}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
        `;
        for (let i = 0; i < maxRows; i++) {
          html += '<tr>';
          for (const cat of categories) {
            const item = grouped[cat][i];
            html += '<td>';
            if (item) {
              html += `<a href="${item.arg}" target="_blank">${item.title}</a>`;
            } else {
              html += '';
            }
            html += '</td>';
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        document.getElementById('bookmarksTable').innerHTML = html;
      }

      const addBookmarkForm = document.getElementById('addBookmarkForm');
      const addBookmarkStatus = document.getElementById('addBookmarkStatus');

      addBookmarkForm.addEventListener('submit', function (e) {
        e.preventDefault();
        addBookmarkStatus.textContent = '';
        const data = {
          title: document.getElementById('bmTitle').value,
          arg: document.getElementById('bmArg').value,
          category_id: parseInt(document.getElementById('bmCategory').value, 10)
        };

        fetch('/api/bookmarks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
          .then(res => {
            if (res.status === 200 || res.status === 201) {
              // Try to parse JSON, but log if it fails
              return res.json().catch(err => {
                console.error("Failed to parse JSON response:", err);
                throw err;
              });
            } else {
              console.error("API responded with error status:", res.status, res.statusText);
              return Promise.reject(res.statusText);
            }
          })
          .then(responseData => {
            console.log("API response JSON:", responseData);
            addBookmarkStatus.textContent = 'Bookmark added!';
            addBookmarkStatus.style.color = 'green';
            addBookmarkForm.reset();
            loadBookmarksTable();
          })
          .catch(err => {
            console.error("Bookmark add failed:", err);
            addBookmarkStatus.textContent = 'Failed to add bookmark.';
            addBookmarkStatus.style.color = 'red';
          });
      });

      // Populate category dropdown from /api/categories
      function loadCategoriesDropdown() {
        fetch('/api/categories?exclude_hidden=true')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => {
            console.log("Posting categories data:", data);
            const select = document.getElementById('bmCategory');
            select.innerHTML = '';
            categoryIdToName = {};
            if (Array.isArray(data) && data.length) {
              data.forEach(cat => {
                categoryIdToName[cat.id] = cat.name;
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.name;
                select.appendChild(opt);
              });
            } else {
              const opt = document.createElement('option');
              opt.value = '';
              opt.textContent = 'No categories found';
              select.appendChild(opt);
            }
            // Load bookmarks only after categories are loaded
            loadBookmarksTable();
          })
          .catch(() => {
            const select = document.getElementById('bmCategory');
            select.innerHTML = '';
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Failed to load categories';
            select.appendChild(opt);
            // Still try to load bookmarks
            loadBookmarksTable();
          });
      }

      // Call this on page load
      loadCategoriesDropdown();

      let categoryIdToName = {};
    </script>

  </main>

</body>

</html>