<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>home service</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/milligram/1.4.1/milligram.min.css" />
  <link rel="stylesheet" href="https://milligram.io/styles/main.css" />
  <style>
    .drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      color: #888;
      margin-top: 2em;
      transition: border-color 0.2s;
    }

    .drop-zone.dragover {
      border-color: #333;
      background: #f9f9f9;
      color: #333;
    }

    .drop-zone input {
      display: none;
    }

    #progressContainer {
      width: 100%;
      background: #eee;
      border-radius: 4px;
      margin: 1em 0;
      height: 18px;
      display: none;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: #9b4dca;
      border-radius: 4px;
      transition: width 0.2s;
    }

    .logout-btn {
      margin-bottom: 2em;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background-color: #f4f4f4;
    }

    tr:hover {
      background-color: #f1f1f1;
    }
  </style>
</head>

<body>
  <main class="wrapper">

    <section class="container" id="examples">
      <h1 class="title">home service</h1>

      <h4>Bookmarks</h4>
      <div id="bookmarksTable" style="overflow-x:auto; margin-bottom:2em;">
        Loading bookmarks...
      </div>

      <h4>Add Bookmark</h4>
      <form id="addBookmarkForm" style="margin-bottom:2em;">
        <div style="display: flex; flex-wrap: wrap; gap: 16px;">
          <div style="flex:1; min-width:180px;">
            <label for="bmTitle">Title</label>
            <input type="text" id="bmTitle" name="title" required />
          </div>
          <div style="flex:1; min-width:180px;">
            <label for="bmArg">URL</label>
            <input type="url" id="bmArg" name="arg" required />
          </div>
          <div style="flex:1; min-width:180px;">
            <label for="bmCategory">Category</label>
            <select id="bmCategory" name="category" required>
              <option value="">Loading...</option>
            </select>
          </div>
        </div>
        <button type="submit" class="button" style="margin-top:12px;">Add Bookmark</button>
        <span id="addBookmarkStatus" style="margin-left:1em;"></span>
      </form>


      <h4>
        <button id="toggleUploads" style="font-size:1em;">►</button>
        File uploads
      </h4>
      <div id="uploadsSection" style="display:none;">
        <form id="uploadForm" action="/api/upload" method="post" enctype="multipart/form-data">
          <div style="display: flex; align-items: flex-start; gap: 16px;">
            <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
              <label for="targetEmail">Target email address</label>
              <select id="targetEmail" name="targetEmail">
                <option value="private">Private</option>
                <option value="work">Work</option>
              </select>
              <label for="subject">Subject</label>
              <input type="text" id="subject" name="subject" placeholder="Enter subject..." />
              <label for="message">Description</label>
              <textarea id="message" name="message" placeholder="Enter message..." rows="4" style="resize:vertical;"></textarea>
            </div>
            <div style="flex: 0 0 220px; display: flex; flex-direction: column; align-items: stretch; gap: 8px;">
              <div class="drop-zone" id="dropZone" style="padding: 18px; min-height: 60px;">
                <span id="dropZoneText">Drag &amp; drop files<br>or click</span>
                <input type="file" name="file" id="fileInput" multiple />
              </div>
              <div id="fileListPreview" style="font-size: 0.95em; min-height: 24px; margin-top: 4px;"></div>
            </div>
          </div>
          <div id="progressContainer">
            <div id="progressBar"></div>
          </div>
          <div style="height: 24px;"></div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <button type="submit" class="button">Upload</button>
            <label style="margin-bottom:0;">
              <input type="checkbox" id="onlyUploadCheckbox" name="onlyUpload" value="true" />
              Only upload files
            </label>
          </div>
        </form>
        <div id="uploadStatus"></div>
      </div>

      <h4>
        <button id="toggleFileList" style="font-size:1em;">►</button>
        File list
      </h4>
      <div id="fileListSection" style="display:none;">
        <div id="fileList">
          Loading...
        </div>
      </div>
      <h4>
        <button id="toggleStats" style="font-size:1em;">►</button>
        Statistics
      </h4>
      <div id="statsSection" style="width:100%; max-width:100%; margin-bottom:2em; display:none;">
        <div id="statsChart">
          Loading statistics...
        </div>
      </div>

    </section>

    <script>
      const dropZone = document.getElementById('dropZone');
      const fileInput = document.getElementById('fileInput');
      const dropZoneText = document.getElementById('dropZoneText');
      const uploadForm = document.getElementById('uploadForm');
      const uploadStatus = document.getElementById('uploadStatus');
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const fileListPreview = document.getElementById('fileListPreview');

      function updateFileListPreview(files) {
        if (!files || files.length === 0) {
          fileListPreview.textContent = '';
          return;
        }
        const names = Array.from(files).map(f => f.name);
        fileListPreview.innerHTML = '<strong>Selected:</strong><br>' + names.join('<br>');
      }

      dropZone.addEventListener('click', () => fileInput.click());

      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        if (e.dataTransfer.files.length) {
          fileInput.files = e.dataTransfer.files;
          updateFileListPreview(fileInput.files);
          if (fileInput.files.length === 1) {
            dropZoneText.textContent = fileInput.files[0].name;
          } else {
            dropZoneText.textContent = fileInput.files.length + " files selected";
          }
        }
      });

      fileInput.addEventListener('change', () => {
        updateFileListPreview(fileInput.files);
        if (fileInput.files.length) {
          if (fileInput.files.length === 1) {
            dropZoneText.textContent = fileInput.files[0].name;
          } else {
            dropZoneText.textContent = fileInput.files.length + " files selected";
          }
        } else {
          dropZoneText.textContent = 'Drag & drop files<br>or click';
        }
      });

      uploadForm.addEventListener('submit', function (e) {
        e.preventDefault();
        const formData = new FormData(uploadForm);

        // Add checkbox value explicitly (in case unchecked, value won't be sent)
        formData.set('onlyUpload', document.getElementById('onlyUploadCheckbox').checked ? 'true' : 'false');

        // Add subject, message, and targetEmail values explicitly
        formData.set('subject', document.getElementById('subject').value);
        formData.set('message', document.getElementById('message').value);
        formData.set('targetEmail', document.getElementById('targetEmail').value);

        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        uploadStatus.textContent = '';
        uploadStatus.style.color = ''; // Reset color
        uploadStatus.style.fontSize = ''; // Reset font size

        const xhr = new XMLHttpRequest();
        xhr.open('POST', uploadForm.action, true);

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 100);
            progressBar.style.width = percent + '%';
          }
        };

        xhr.onload = function () {
          progressBar.style.width = '100%';
          if (xhr.status >= 200 && xhr.status < 300) {
            uploadStatus.textContent = 'Upload successful!';
            uploadStatus.style.color = '';
            uploadStatus.style.fontSize = '';
            loadFileList(); // reload file list after successful upload
          } else {
            uploadStatus.textContent = 'Upload failed.';
            uploadStatus.style.color = 'red';
            uploadStatus.style.fontSize = '1.5em';
          }
          setTimeout(() => {
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
          }, 1200);
        };

        xhr.onerror = function () {
          uploadStatus.textContent = 'Upload failed.';
          uploadStatus.style.color = 'red';
          uploadStatus.style.fontSize = '1.5em';
          progressContainer.style.display = 'none';
          progressBar.style.width = '0%';
        };

        xhr.send(formData);
      });

      // State for sorting
      let fileListData = [];
      let sortColumn = 'name';
      let sortAsc = true;

      // Fetch and display file list as a sortable table
      function loadFileList() {
        fetch('/api/filelist')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => {
            fileListData = data.files || [];
            renderFileTable();
          })
          .catch(() => {
            document.getElementById('fileList').textContent = 'Failed to load file list.';
          });
      }

      function renderFileTable() {
        const fileListDiv = document.getElementById('fileList');
        if (!fileListData.length) {
          fileListDiv.textContent = 'No files found.';
          return;
        }

        // Sort data
        const sorted = [...fileListData].sort((a, b) => {
          let vA, vB;
          if (sortColumn === 'name') {
            vA = a.name.toLowerCase();
            vB = b.name.toLowerCase();
          } else if (sortColumn === 'size') {
            vA = a.size;
            vB = b.size;
          } else if (sortColumn === 'modTime') {
            vA = new Date(a.modTime);
            vB = new Date(b.modTime);
          }
          if (vA < vB) return sortAsc ? -1 : 1;
          if (vA > vB) return sortAsc ? 1 : -1;
          return 0;
        });

        // Table headers with sort indicators
        function th(label, col) {
          let arrow = '';
          if (sortColumn === col) arrow = sortAsc ? ' ▲' : ' ▼';
          return `<th style="cursor:pointer;" onclick="sortFileTable('${col}')">${label}${arrow}</th>`;
        }

        let table = `<table style="width:100%;border-collapse:collapse;">
          <thead>
            <tr>
              ${th('File', 'name')}
              ${th('Size', 'size')}
              ${th('Age', 'modTime')}
            </tr>
          </thead>
          <tbody>
        `;
        table += sorted.map(f => {
          // Format size in KB/MB
          let size = f.size;
          if (size > 1024 * 1024) {
            size = (size / (1024 * 1024)).toFixed(2) + ' MB';
          } else if (size > 1024) {
            size = (size / 1024).toFixed(2) + ' KB';
          } else {
            size = size + ' B';
          }
          // Calculate age
          const age = getFileAge(f.modTime);
          return `<tr>
            <td><a href="/api/download?filename=${encodeURIComponent(f.name)}" download>${f.name}</a></td>
            <td style="text-align:right;">${size}</td>
            <td style="text-align:right;">${age}</td>
          </tr>`;
        }).join('');
        table += '</tbody></table>';
        fileListDiv.innerHTML = table;
      }

      // Sorting handler
      window.sortFileTable = function(col) {
        if (sortColumn === col) {
          sortAsc = !sortAsc;
        } else {
          sortColumn = col;
          sortAsc = true;
        }
        renderFileTable();
      };

      // Helper to format file age from ISO string
      function getFileAge(modTime) {
        const mod = new Date(modTime);
        const now = new Date();
        const diffMs = now - mod;
        const diffSec = Math.floor(diffMs / 1000);
        const diffMin = Math.floor(diffSec / 60);
        const diffHr = Math.floor(diffMin / 60);
        const diffDay = Math.floor(diffHr / 24);

        if (diffDay > 0) return diffDay + ' day' + (diffDay > 1 ? 's' : '') + ' ago';
        if (diffHr > 0) return diffHr + ' hour' + (diffHr > 1 ? 's' : '') + ' ago';
        if (diffMin > 0) return diffMin + ' min ago';
        return diffSec + ' sec ago';
      }

      function renderStatsChart(stats) {
        if (!stats || !stats.length) {
          document.getElementById('statsChart').textContent = 'No statistics found.';
          return;
        }
        // Match file list width
        let table = `<table style="width:100%;table-layout:fixed;border-collapse:collapse;">
          <thead>
            <tr>
              <th style="width:40%;text-align:left;">Source</th>
              <th style="width:40%;text-align:left;">Bar</th>
              <th style="width:20%;text-align:right;">Count</th>
            </tr>
          </thead>
          <tbody>
        `;
        const max = Math.max(...stats.map(s => s.count));
        stats.forEach(s => {
          const width = max ? (s.count / max * 100) : 0;
          table += `<tr>
            <td style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${s.source}</td>
            <td>
              <div style="background:#9b4dca;height:18px;width:${width}%;min-width:2px;display:inline-block;"></div>
            </td>
            <td style="text-align:right;">${s.count}</td>
          </tr>`;
        });
        table += '</tbody></table>';
        document.getElementById('statsChart').innerHTML = table;
      }

      function loadStats() {
        fetch('/api/stats')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => renderStatsChart(data.stats))
          .catch(() => {
            document.getElementById('statsChart').textContent = 'Failed to load statistics.';
          });
      }

      function loadBookmarksTable() {
        fetch('/api/bookmarks')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => {
            console.log("Bookmarks API data:", data); // <-- Print the data to the console
            renderBookmarksTable(data);
          })
          .catch(() => {
            document.getElementById('bookmarksTable').textContent = 'Failed to load bookmarks.';
          });
      }

      function renderBookmarksTable(data) {
        if (!data || !data.items) {
          console.warn("No bookmarks data or items:", data);
          document.getElementById('bookmarksTable').textContent = 'No bookmarks found.';
          return;
        }
        const items = data.items;
        console.log("Rendering bookmarks for items:", items);
        console.log("Current categoryIdToName mapping:", categoryIdToName);

        // Generate unique category names from items using the mapping
        const categories = [
          ...new Set(
            items
              .map(item => categoryIdToName[item.category_id])
              .filter(Boolean)
          )
        ];
        console.log("Categories for table:", categories);

        // Group items by category name
        const grouped = {};
        categories.forEach(cat => grouped[cat] = []);
        items.forEach(item => {
          const catName = categoryIdToName[item.category_id];
          if (grouped[catName]) {
            grouped[catName].push(item);
          }
        });

        // Find max number of items in any category for row count
        const maxRows = Math.max(...categories.map(cat => grouped[cat].length));
        console.log("Max rows:", maxRows);

        // Build table
        let html = `<table style="width:100%;border-collapse:collapse;table-layout:auto;">
          <thead>
            <tr>
              ${categories.map(cat => `<th>${cat}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
        `;
        for (let i = 0; i < maxRows; i++) {
          html += '<tr>';
          for (const cat of categories) {
            const item = grouped[cat][i];
            html += '<td>';
            if (item) {
              html += `<a href="${item.arg}" target="_blank">${item.title}</a>`;
            } else {
              html += '';
            }
            html += '</td>';
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        document.getElementById('bookmarksTable').innerHTML = html;
      }

      // Folding logic for uploads section
      const toggleBtn = document.getElementById('toggleUploads');
      const uploadsSection = document.getElementById('uploadsSection');
      let uploadsVisible = false;

      toggleBtn.addEventListener('click', function() {
        uploadsVisible = !uploadsVisible;
        uploadsSection.style.display = uploadsVisible ? '' : 'none';
        toggleBtn.textContent = uploadsVisible ? '▼' : '►';
      });

      // Folding logic for file list section
      const toggleFileListBtn = document.getElementById('toggleFileList');
      const fileListSection = document.getElementById('fileListSection');
      let fileListVisible = false;

      toggleFileListBtn.addEventListener('click', function() {
        fileListVisible = !fileListVisible;
        fileListSection.style.display = fileListVisible ? '' : 'none';
        toggleFileListBtn.textContent = fileListVisible ? '▼' : '►';
      });

      // Folding logic for statistics section
      const toggleStatsBtn = document.getElementById('toggleStats');
      const statsSection = document.getElementById('statsSection');
      let statsVisible = false;

      toggleStatsBtn.addEventListener('click', function() {
        statsVisible = !statsVisible;
        statsSection.style.display = statsVisible ? '' : 'none';
        toggleStatsBtn.textContent = statsVisible ? '▼' : '►';
      });

      // Initial load
      loadFileList();
      loadStats();

      const addBookmarkForm = document.getElementById('addBookmarkForm');
      const addBookmarkStatus = document.getElementById('addBookmarkStatus');

      addBookmarkForm.addEventListener('submit', function(e) {
        e.preventDefault();
        addBookmarkStatus.textContent = '';
        const data = {
          title: document.getElementById('bmTitle').value,
          arg: document.getElementById('bmArg').value,
          category_id: parseInt(document.getElementById('bmCategory').value, 10)
        };
        console.log("Posting bookmark data:", data);
        fetch('/api/bookmarks', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
        .then(res => {
          console.log("API response status:", res.status);
          if (res.status === 200 || res.status === 201) {
            // Try to parse JSON, but log if it fails
            return res.json().catch(err => {
              console.error("Failed to parse JSON response:", err);
              throw err;
            });
          } else {
            console.error("API responded with error status:", res.status, res.statusText);
            return Promise.reject(res.statusText);
          }
        })
        .then(responseData => {
          console.log("API response JSON:", responseData);
          addBookmarkStatus.textContent = 'Bookmark added!';
          addBookmarkStatus.style.color = 'green';
          addBookmarkForm.reset();
          loadBookmarksTable();
        })
        .catch(err => {
          console.error("Bookmark add failed:", err);
          addBookmarkStatus.textContent = 'Failed to add bookmark.';
          addBookmarkStatus.style.color = 'red';
        });
      });

      // Populate category dropdown from /api/categories
      function loadCategoriesDropdown() {
        fetch('/api/categories')
          .then(res => res.ok ? res.json() : Promise.reject(res.statusText))
          .then(data => {
            const select = document.getElementById('bmCategory');
            select.innerHTML = '';
            categoryIdToName = {};
            if (Array.isArray(data) && data.length) {
              data.forEach(cat => {
                categoryIdToName[cat.id] = cat.name;
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.name;
                select.appendChild(opt);
              });
            } else {
              const opt = document.createElement('option');
              opt.value = '';
              opt.textContent = 'No categories found';
              select.appendChild(opt);
            }
            // Load bookmarks only after categories are loaded
            loadBookmarksTable();
          })
          .catch(() => {
            const select = document.getElementById('bmCategory');
            select.innerHTML = '';
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Failed to load categories';
            select.appendChild(opt);
            // Still try to load bookmarks
            loadBookmarksTable();
          });
      }

      // Call this on page load
      loadCategoriesDropdown();

      let categoryIdToName = {};
    </script>

  </main>

</body>

</html>